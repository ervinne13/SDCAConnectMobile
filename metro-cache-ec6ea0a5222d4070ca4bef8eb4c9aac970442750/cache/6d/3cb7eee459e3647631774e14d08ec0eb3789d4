__d(function (global, require, module, exports, _dependencyMap) {
    'use strict';

    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function (obj) {
        return Object.getOwnPropertyNames(obj).reduce(function (descriptors, name) {
            descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);
            return descriptors;
        }, {});
    };

    function setConstructorOnPrototype(klass) {
        if (klass.prototype.constructor !== klass) {
            Object.defineProperty(klass.prototype, 'constructor', {
                value: klass,
                configurable: true,
                writable: true
            });
        }
    }

    function waitForDownloadConfig(config) {
        if (!config) {
            return {
                _cache: false
            };
        }

        if (typeof config == 'string') {
            return {
                path: config,
                _cache: false
            };
        }

        if (typeof config == 'object') {
            return _extends({}, config, {
                schema: undefined,
                schemaVersion: undefined,
                _cache: false
            });
        }

        return config;
    }

    module.exports = function (realmConstructor) {
        Object.defineProperties(realmConstructor.Collection.prototype, require(_dependencyMap[0], './collection-methods'));
        setConstructorOnPrototype(realmConstructor.Collection);
        setConstructorOnPrototype(realmConstructor.List);
        setConstructorOnPrototype(realmConstructor.Results);
        setConstructorOnPrototype(realmConstructor.Object);
        Object.defineProperties(realmConstructor, getOwnPropertyDescriptors({
            open: function open(config) {
                if (!("sync" in config)) {
                    var _promise = Promise.resolve(new realmConstructor(config));

                    _promise.progress = function (callback) {};

                    return _promise;
                }

                var syncSession = void 0;
                var promise = new Promise(function (resolve, reject) {
                    var realm = new realmConstructor(waitForDownloadConfig(config));

                    realm._waitForDownload(function (session) {
                        syncSession = session;
                    }, function (error) {
                        realm.close();

                        if (error) {
                            setTimeout(function () {
                                reject(error);
                            }, 1);
                        } else {
                            try {
                                var syncedRealm = new realmConstructor(config);
                                setTimeout(function () {
                                    resolve(syncedRealm);
                                }, 1);
                            } catch (e) {
                                reject(e);
                            }
                        }
                    });
                });

                promise.progress = function (callback) {
                    if (syncSession) {
                        syncSession.addProgressNotification('download', 'forCurrentlyOutstandingWork', callback);
                    }

                    return promise;
                };

                return promise;
            },
            openAsync: function openAsync(config, callback, progressCallback) {
                var message = "Realm.openAsync is now deprecated in favor of Realm.open. This function will be removed in future versions.";
                (console.warn || console.log).call(console, message);
                var promise = this.open(config);

                if (progressCallback) {
                    promise.progress(progressCallback);
                }

                promise.then(function (realm) {
                    callback(null, realm);
                }).catch(function (error) {
                    callback(error);
                });
            }
        }));

        if (realmConstructor.Sync) {
            var userMethods = require(_dependencyMap[1], './user-methods');

            Object.defineProperties(realmConstructor.Sync.User, getOwnPropertyDescriptors(userMethods.static));
            Object.defineProperties(realmConstructor.Sync.User.prototype, getOwnPropertyDescriptors(userMethods.instance));
            Object.defineProperty(realmConstructor.Sync.User, '_realmConstructor', {
                value: realmConstructor
            });
            realmConstructor.Sync.AuthError = require(_dependencyMap[2], './errors').AuthError;

            if (realmConstructor.Sync.removeAllListeners) {
                process.on('exit', realmConstructor.Sync.removeAllListeners);
                process.on('SIGINT', function () {
                    realmConstructor.Sync.removeAllListeners();
                    process.exit(2);
                });
                process.on('uncaughtException', function (e) {
                    realmConstructor.Sync.removeAllListeners();
                    console.log(e.stack);
                    process.exit(99);
                });
            }

            setConstructorOnPrototype(realmConstructor.Sync.User);
            setConstructorOnPrototype(realmConstructor.Sync.Session);

            if (realmConstructor.Sync._setFeatureToken) {
                realmConstructor.Sync.setFeatureToken = function (featureToken) {
                    if (typeof featureToken !== 'string' && !(featureToken instanceof String)) {
                        throw new Error("featureToken should be a string");
                    }

                    realmConstructor.Sync._setFeatureToken(featureToken.trim());
                };
            }

            realmConstructor.prototype.subscribeToObjects = function (objectType, query) {
                var realm = this;
                var promise = new Promise(function (resolve, reject) {
                    realm._subscribeToObjects(objectType, query, function (err, results) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(results);
                        }
                    });
                });
                return promise;
            };
        }

        var types = Object.freeze({
            'BOOL': 'bool',
            'INT': 'int',
            'FLOAT': 'float',
            'DOUBLE': 'double',
            'STRING': 'string',
            'DATE': 'date',
            'DATA': 'data',
            'OBJECT': 'object',
            'LIST': 'list'
        });
        Object.defineProperty(realmConstructor, 'Types', {
            get: function get() {
                if (typeof console != 'undefined') {
                    var stack = new Error().stack.split("\n").slice(2).join("\n");
                    var msg = '`Realm.Types` is deprecated! Please specify the type name as lowercase string instead!\n' + stack;

                    if (console.warn != undefined) {
                        console.warn(msg);
                    } else {
                        console.log(msg);
                    }
                }

                return types;
            },
            configurable: true
        });
    };
});