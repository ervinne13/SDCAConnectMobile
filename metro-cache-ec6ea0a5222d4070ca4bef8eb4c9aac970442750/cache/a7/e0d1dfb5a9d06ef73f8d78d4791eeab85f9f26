__d(function (global, require, module, exports, _dependencyMap) {
  var _lodash = require(_dependencyMap[0], "lodash");

  var _lodash2 = _interopRequireDefault(_lodash);

  var _realm = require(_dependencyMap[1], "realm");

  var _realm2 = _interopRequireDefault(_realm);

  var _Task = require(_dependencyMap[2], "../models/Task");

  var _Task2 = _interopRequireDefault(_Task);

  var _TaskAPI = require(_dependencyMap[3], "../api/TaskAPI");

  var _TaskAPI2 = _interopRequireDefault(_TaskAPI);

  var _schema = require(_dependencyMap[4], "../schema/schema");

  var _schema2 = _interopRequireDefault(_schema);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var repository = _schema2.default;
  var TaskService = {
    beginSync: function beginSync(server, authToken) {
      var api, webTasks, tasks, lodashTaskItems;
      return regeneratorRuntime.async(function beginSync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.log('Starting sync task');
              api = new _TaskAPI2.default(server, authToken);
              _context.next = 4;
              return regeneratorRuntime.awrap(api.getTasks());

            case 4:
              webTasks = _context.sent;
              console.log('Tasks Fetched', webTasks);

              if (webTasks.length) {
                _context.next = 9;
                break;
              }

              console.log('No tasks available');
              return _context.abrupt("return");

            case 9:
              webTasks.forEach(function (webTask) {
                console.log(webTask);
                TaskService.save(new _Task2.default(webTask));
              });
              tasks = TaskService.findAll();
              tasks.forEach(function (task) {
                console.log(task);
                console.log(task.id);
              });

              if (tasks.length) {
                lodashTaskItems = _lodash2.default.values(tasks[0].items);
                console.log(lodashTaskItems);
              }

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    },
    find: function find(id) {
      var result = repository.objects('Task').filtered("id = '" + id + "'");

      if (result.length) {
        return result[0];
      } else {
        throw new Error('Task with id: ' + id + ' not found');
      }
    },
    findAll: function findAll(sortBy) {
      if (!sortBy) sortBy = [['id', false], ['displayName', true]];
      return repository.objects('Task').sorted(sortBy);
    },
    save: function save(task) {
      if (repository.objects('Task').filtered("id = '" + task.id + "'").length) {
        return TaskService.update(task);
      }

      return new Promise(function (resolve) {
        repository.write(function () {
          task.createdAt = new Date();
          repository.create('Task', task);
          resolve(task);
        });
      });
    },
    update: function update(task) {
      return new Promise(function (resolve) {
        repository.write(function () {
          task.updatedAt = new Date();
          resolve(task);
        });
      });
    }
  };
  module.exports = TaskService;
});